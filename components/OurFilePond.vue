<template>
  <div>
    <file-pond
      v-if="supported"
      ref="pond"
      name="photo"
      :allow-multiple="multiple"
      accepted-file-types="image/*"
      :file-validate-type-detect-type="validateType"
      :files="myFiles"
      image-resize-target-width="800"
      image-resize-target-height="800"
      image-crop-aspect-ratio="1"
      label-idle="Drag & Drop photos or <span class=&quot;btn btn-white&quot;> Browse </span>"
      :server="{ process, revert, restore, load, fetch }"
      :drop-on-element="false"
      :drop-on-page="true"
      :max-parallel-uploads="1"
      @init="photoInit"
      @processfile="processed"
      @processfiles="allProcessed"
    />
    <div v-else>
      Sorry, photo uploads aren't supported on this browser.  Maybe it's old?
    </div>
  </div>
</template>
<script>
// accepted-file-types="image/jpeg, image/png, image/gif, image/jpg"
import 'filepond/dist/filepond.min.css'
import 'filepond-plugin-image-preview/dist/filepond-plugin-image-preview.min.css'
import vueFilePond from 'vue-filepond'
import FilePondPluginFileValidateType from 'filepond-plugin-file-validate-type'
import FilePondPluginImagePreview from 'filepond-plugin-image-preview'
import FilePondPluginImageTransform from 'filepond-plugin-image-transform'
import FilePondPluginImageResize from 'filepond-plugin-image-resize'
import FilePondPluginImageExifOrientation from 'filepond-plugin-image-exif-orientation'
import { mobilestate } from '@/plugins/app-init-push' // CC

let heic2any = null

if (process.client) {
  heic2any = require('heic2any')
}

var Sentry
try {
  Sentry = cordova.require("sentry-cordova.Sentry")
}
catch (e) { }

const FilePond = vueFilePond(
  FilePondPluginFileValidateType,
  FilePondPluginImagePreview,
  FilePondPluginImageTransform,
  FilePondPluginImageResize,
  FilePondPluginImageExifOrientation
)

export default {
  components: {
    FilePond
  },
  props: {
    imgtype: {
      type: String,
      required: true
    },
    imgflag: {
      type: String,
      required: true
    },
    ocr: {
      type: Boolean,
      required: false,
      default: false
    },
    identify: {
      type: Boolean,
      required: false,
      default: false
    },
    browse: {
      type: Boolean,
      required: false,
      default: true
    },
    multiple: {
      type: Boolean,
      required: false,
      default: false
    },
    msgid: {
      type: Number,
      required: false,
      default: null
    },
    groupid: {
      type: Number,
      required: false,
      default: null
    }
  },
  data: function() {
    return {
      imageid: null,
      imagethumb: null,
      image: null,
      ocred: null,
      identified: null,
      myFiles: [],
      supported: true
    }
  },
  methods: {
    takeAppPhoto: function () { // CC
      console.log("TAKE APP PHOTO")
      const maxDimension = 800
      navigator.camera.getPicture(imageURI => {
          this.cameraSuccess(imageURI)
        }, msg => {
          this.cameraError(msg)
        },
        {
          quality: 50,
          destinationType: Camera.DestinationType.DATA_URL,
          //destinationType: Camera.DestinationType.FILE_URI,
          sourceType: Camera.PictureSourceType.CAMERA,
          //allowEdit: true,	// Don't: adds unhelpful crop photo step
          encodingType: Camera.EncodingType.JPEG,
          targetWidth: maxDimension,
          targetHeight: maxDimension,
          //popoverOptions: CameraPopoverOptions,
          //saveToPhotoAlbum: true, // Commented out as causes error in Android 10+
          correctOrientation: true
        }
      )
    },
    cameraError: function (msg) {
      console.log("PHOTO: cameraError")
      setTimeout(function () {
        if (msg === "No Image Selected") { msg = "No photo taken or chosen" }
        if (msg === "Camera cancelled") { msg = "No photo taken or chosen" }
        console.log(msg)
        document.getElementById('camera-msg').innerHTML = msg
        setTimeout(function () {
          document.getElementById('camera-msg').innerHTML = ''
        }, 3000)
      }, 0)
    },
    cameraSuccess: function (imageData) {
      console.log("PHOTO: cameraSuccess")
      console.log("cameraSuccess size:" + imageData.length)
      const contentType = 'image/jpeg'
      const sliceSize = 512

      const byteCharacters = atob(imageData)
      const byteArrays = []

      for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        let slice = byteCharacters.slice(offset, offset + sliceSize)

        let byteNumbers = new Array(slice.length)
        for (let i = 0; i < slice.length; i++) {
          byteNumbers[i] = slice.charCodeAt(i)
        }

        let byteArray = new Uint8Array(byteNumbers)

        byteArrays.push(byteArray)
      }

      const imageBlob = new Blob(byteArrays, { type: contentType })

      this.$refs.pond.addFile(imageBlob)
    },
    photoInit: function () {
      console.log('PHOTO: photoInit') // CC
      if (process.env.IS_APP) {
        if (mobilestate.isiOS) {
          this.$refs.pond.labelIdle = '<div><span class="filepond--label-action btn btn-white">Take a photo or Browse</span></div><div id="camera-msg"></div>'
          if (this.browse) {
            this.$refs.pond.browse()
          }
        } else {
          this.$refs.pond.labelIdle = '<div><span class="take-photo btn btn-primary">Take Photo</span> or <span class="btn btn-white">Browse</span></div><div id="camera-msg"></div>'
          setTimeout(() => { // this.$nextTick didn't work
            const takePhoto = this.$el.querySelector('.take-photo')
            takePhoto.addEventListener('click', e => {
              this.takeAppPhoto()
              e.preventDefault()
              return false
            })
          }, 300)
        }
        if (this.browse) {
          // NO: don't show camera automatically: this.takeAppPhoto()
        }
      }
      else if (!this.$refs.pond._pond) {
        // This is the only way of finding out if the browser is supported - see
        // https://github.com/pqina/vue-filepond/issues/136
        this.supported = false
      } else {
        this.$emit('init')

        if (this.browse) {
          // We have rendered the filepond instance.  Trigger browse so that they can upload a photo without an
          // extra click.
          this.$refs.pond.browse()
        }
      }
    },
    async process(fieldName, file, metadata, load, error, progress, abort) {
      console.log('Process')
      await this.$store.dispatch('compose/setUploading', true)

      const data = new FormData()
      const fn = file.name.toLowerCase()

      if (fn.indexOf('.heic') !== -1) {
        // If we have an HEIC file, then the server can't cope with it as it will fail imagecreatefromstring, so
        // convert it to a PNG file on the client before upload.  We have to restrict the quality to keep the cconversion
        // time reasonable.
        const blob = file.slice(0, file.size, 'image/heic')
        const png = await heic2any({ blob, toType: 'image/jpeg', quality: 0.1 })
        data.append('photo', png, 'photo')

        if (!png && Sentry) {
          Sentry.captureException(
            'Failed to convert HEIC to JPEG size ' + file.size
          )
        }
      } else {
        data.append('photo', file, 'photo')

        if (!file && Sentry) {
          Sentry.captureException(
            'Passed empty file for upload' + JSON.stringify(file)
          )
        }
      }

      data.append(this.imgflag, true)
      data.append('imgtype', this.imgtype)
      data.append('ocr', this.ocr)
      data.append('identify', this.identify)
      if (this.msgid) {
        data.append('msgid', this.msgid)
      } else if (this.groupid) {
        data.append('groupid', this.groupid)
      }

      const ret = await this.$axios.post(process.env.API + '/image', data, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUpLoadProgress: e => {
          progress(e.lengthComputable, e.loaded, e.total)
        }
      })

      console.log('Returned', JSON.parse(JSON.stringify(ret)))
      if (ret.status === 200 && ret.data.ret === 0) {
        this.imageid = ret.data.id
        this.imagethumb = ret.data.paththumb
        this.image = ret.data.path

        if (this.ocr) {
          this.ocred = ret.data.ocr
        }

        if (this.identify) {
          this.identified = ret.data.items
        }

        load(ret.data.id)
      } else {
        console.log('process Error',ret)
        error(
          ret.status === 200 ? ret.data.status : 'Network error ' + ret.status
        )
      }

      return {
        abort: () => {
          // We don't need to do anything - the server will tidy up hanging images.
          abort()
        }
      }
    },
    load(uniqueFileId, load, error) {},
    fetch(url, load, error, progress, abort, headers) {},
    restore(uniqueFileId, load, error, progress, abort, headers) {},
    revert(uniqueFileId, load, error) {},

    processed(error, file) {
      if (error) {
        console.log('processed Error', error)
      } else {
        this.$emit(
          'photoProcessed',
          this.imageid,
          this.imagethumb,
          this.image,
          this.ocred,
          this.identified
        )

        if (!this.multiple) {
          // Only one, so the allProcessed event isn't fired by pond.
          this.allProcessed()
        }
      }
    },

    addFile(f) {
      this.$refs.pond.addFile(f)
    },

    async allProcessed() {
      await this.$store.dispatch('compose/setUploading', false)
      this.$emit('allProcessed')
    },

    detector(source, type) {
      // This function is never executed...
      return new Promise((resolve, reject) => {
        console.log(source, type)
        if (source.name.indexOf('.heic') !== -1) {
          // This is not detected automatically.
          type = 'image/heic'
        }

        resolve(type)
      })
    },
    validateType(source, type) {
      const p = new Promise((resolve, reject) => {
        // Not all browsers set the MIME type correctly, so we have a custom validator to force it from the filename.
        if (source.name.toLowerCase().indexOf('.heic') !== -1) {
          resolve('image/heic')
        } else {
          resolve(type)
        }
      })

      return p
    }
  },
  blockkey(e) {
    // We're blocking all interaction with this div while the load happens.
    e.returnValue = false
    return false
  }
}
</script>
<style scoped lang="scss">
@import 'color-vars';

/deep/ .filepond--root {
  .filepond--drop-label {
    background-color: $colour-success-bg;

    label {
      font-weight: bold;
    }

    .btn {
      background-color: $colour-success !important;
      border-color: $colour-success !important;
      color: $color-white !important;

      &:hover {
        background-color: $colour-success-hover !important;
      }
    }
  }
}
</style>
